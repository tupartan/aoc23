# Advent Of Code 2023 - Let's see how far I get this time
## Day 0
### Hello to me
My name is Tuomas and I am a software tester. I have been testing for a living about 20 years now and I have seen quite many different kinds of setups. Agile, Waterfall, large enterprise software programs, embedded mobile phone development programs, have been a developer, tester, manager, customer support, trainer, a powerpoint man, ... 

One thing I have really enjoyed, but never mastered, is programming. Sure I can create whatever Object Oriented Programming lessons from school had taught me, but I always end up with hundreds of lines of code where masters of code can do with tens of lines of code (and even though I see their code, it is usually quite incomprehensible). But as a stubborn finnish man, I still pursue to improve my coding skills and challenge myself.

I have started this AoC once, or twice, never really finishing. Last time I tried with Python. I guess now I have some hours still to decide between Python, Java or JavaScript. So my goal is to finish. I can be last no matter, but getting to the end would be nice.

## Day 1
### Good morning and good night
So my puzzle solving begins. First things first is to remind myself (google) of basics. I was suprised how quickly I was able to remember and churn the puzzle with Python so maybe it is like riding a bike. After a few falls and bruises I buried the first puzzle. But the second part, ... phew..., test inputs did not uncover a flaw in my approach and before I figured which input row was not interpreted correctly, I was able to get the right answer. Maybe google helped me to find rows behaving badly. Just before midnight.

## Day 2
### Coding in the middle of the forest
Today I was able to jump in to this only in the later afternoon. In addition to my day job I have a hobby, or some might call it a  profession, which obligates me to be in the middle of forest once or twice a year. Luckily I have pretty decent accommodation and good wifi so I have a good setup for solving todays puzzle. Coding parts today were simple and straight forward; rules of the puzzle were not, so first part of the puzzle took more time than it needed, but second part was easy and no need to stay until midnight.

## Day 3
### Not funny
Seven minutes before midnight I solved this. After a weekend in the middle of the forest, I was looking forward to relax and enjoy a peaceful evening. Sod it. I was determined to solve today's puzzle, but even though with valid approach, extensive testing, fixing and testing, fixing I finally got there with first puzzle. It took me a lot of time. Luckily second part was just minor adjustements (krhm. hacks) so still, but barely, in target. Good night.

## Day 4
### Logic vs. efficiency
Today was the first coding tasks that hinted that my code should be efficient rather than meeting my standards for logic. Second part of the puzzle took few seconds to run, I got the right answer at first try, but previous attempts with aocs' have taught me that in puzzles to come I need to learn new tricks especially producing more efficient code. I asked from ChatGPT, but even though attempts were made, I don't think code performance was more efficient when compared to my solution. Then checked reddit for alternative solution and found a one made with 9 lines of code (mine was about 50) and boy it was fast. So human beat the AI.

## Day5
### Brute forcing
So it was today that these performance puzzles came. Length and complexity of the rules were appalling. I read those quite a few times, had some coffee, read instrucions again, repeat... but once pieces were in place, solution ran like a dream. Until part 2. Which is pretty much the same but a looooooot of more numbers to run. So after more than 3 hours of waiting, I am thinking of stopping for tonight and see if there are answers tomorrow morning.

## Day 6
### Still brute forcing
Day 5 part 2 has not finished its run. So naturally I ignored that problem and moved on. Day 6 had the same vibes as day 5; first part was pretty straight forward and easy to do and second part gave an impression that here we go with brute forcing again. I was pretty shocked that part 2 brute forced itself in mere seconds. So as the day 6 is finished, I need to revisit day 5 and try to read posts and hints about effective solutions and try it myself. Let's see...

## Day 7
### Testing testing
Day after day 7 - it was straight forward and itself easy to code. What is coming apparent, besides thinking from performance point-of-view, is to approach these puzzles form testing pow. Most of the times the test input given is not enoght to cover all the cases so it will take some time to debug and find bugs in one's code. Reddit community has helped with that, but how about implementing that in one's ways of coding.

## Day 8
### What is LCM
One those days, yes, where first part of the puzzle is easy, logical and fun to code. Then there is part 2 and it's day 5 all over again. I almost gave up on this until someone mentioned lcm. Not really sure how someone could come up with that this can be solved with LCM but sure it worked. So when the code works, don't touch it? Ok, maybe I will leave the code alone, but still, some more understanding would be beneficial.